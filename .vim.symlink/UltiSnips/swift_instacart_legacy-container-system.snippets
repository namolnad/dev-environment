snippet modulecontroller "Legacy ModuleController implementation" b
import CarrotCore

final class ${1:ModuleName}ModuleController: GenericModuleController<${1:ModuleName}Module, ${1:ModuleName}ModuleView> {
    override class var supportedModuleTypes: Set<ModuleType> {
        return [ModuleType.${2:moduleName}]
    }
}
endsnippet

snippet moduledata "Legacy ModuleData implementation" b
import CarrotCore
import Mapper

typealias ${1:ModuleName}Module = BaseModule<${1:ModuleName}ModuleData>

struct ${1:ModuleName}ModuleData: ModuleData, Codable {
    enum CodingKeys: String, CodingKey {
        case ${2:PropertyName}
    }

    let ${2:PropertyName}: ${3:PropertyType}

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.${2:PropertyName} = container.decode(key: .${2:PropertyName}, default: [])
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(${2:PropertyName}, forKey: .${2:PropertyName})
    }
}

extension ${1:ModuleName}ModuleData: Mappable {
    init(map: Mapper) throws {
        self.${2:PropertyName} = map.optionalFrom(CodingKeys.${2:PropertyName}.stringValue) ?? []
    }
}
endsnippet

snippet moduleview "Legacy ModuleView implementation" b
final class ${1:ModuleName}ModuleView: ModuleView<${1:ModuleName}Module> {
    override func setup() {
        backgroundColor = .white
    }

    override func configure(module: ${1:ModuleName}Module) {
        guard let data = module.data else {
            return
        }

        setNeedsLayout()
    }

    override func prepareForReuse() {
        super.prepareForReuse()
    }

    override func measure(_ size: CGSize, layout: Bool) -> CGSize {
        return .zero
    }
}
endsnippet
