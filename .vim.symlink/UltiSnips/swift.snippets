snippet label "UILabel using sn_tap" b
private let ${1:LabelName}Label: UILabel = .sn_tap { label in
    label.backgroundColor = .white
    label.font = .sn_font(size: 16, weight: .semibold)
    label.textColor = .sn_text
    label.numberOfLines = 0
}
endsnippet

snippet interactor "Interactor type boilerplate" b
import CarrotCore
import RxSwift

protocol ${1:name}InteractorOutputType: class {
    func dispatch(${2:response_name} event: RequestEvent<${3:response_model}>)
}

protocol ${1:name}InteractorType: class {
    weak var output: ${1:name}InteractorOutputType? { get set }

    func get(parameters: [String: Any]?)
}

final class ${1:name}Interactor: ${1:name}InteractorType {
    weak var output: ${1:name}InteractorOutputType?

    private let disposeBag = DisposeBag()

    func get(parameters: [String: Any]? = nil) {
        output?.dispatch(${2:response_name}: .loading(true))

    }
}
endsnippet

snippet modulecontroller "Legacy ModuleController implementation" b
import CarrotCore

final class ${1:ModuleName}ModuleController: GenericModuleController<${1:ModuleName}Module, ${1:ModuleName}ModuleView> {
    override class var supportedModuleTypes: Set<ModuleType> {
        return [ModuleType.${2:moduleName}]
    }
}
endsnippet

snippet moduledata "Legacy ModuleData implementation" b
import CarrotCore
import Mapper

typealias ${1:ModuleName}Module = BaseModule<${1:ModuleName}ModuleData>

struct ${1:ModuleName}ModuleData: ModuleData, Codable {
    enum CodingKeys: String, CodingKey {
        case ${2:PropertyName}
    }

    let ${2:PropertyName}: ${3:PropertyType}

    init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        self.${2:PropertyName} = container.decode(key: .${2:PropertyName}, default: [])
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(${2:PropertyName}, forKey: .${2:PropertyName})
    }
}

extension ${1:ModuleName}ModuleData: Mappable {
    init(map: Mapper) throws {
        self.${2:PropertyName} = map.optionalFrom(CodingKeys.${2:PropertyName}.stringValue) ?? []
    }
}
endsnippet

snippet moduleview "Legacy ModuleView implementation" b
final class ${1:ModuleName}ModuleView: ModuleView<${1:ModuleName}Module> {
    override func setup() {
        backgroundColor = .white
    }

    override func configure(module: ${1:ModuleName}Module) {
        guard let data = module.data else {
            return
        }

        setNeedsLayout()
    }

    override func prepareForReuse() {
        super.prepareForReuse()
    }

    override func measure(_ size: CGSize, layout: Bool) -> CGSize {
        return .zero
    }
}
endsnippet

snippet presenter "PresenterType boilerplate" b
import CarrotCore
import RxSwift

protocol ${1:name}PresenterOutputType: class {
    func dispatch(${2:event_name} event: RequestEvent<${3:model_type}>)
}

protocol ${1:name}PresenterType {
    weak var output: ${1:name}PresenterOutputType? { get set }

    var interactor: ${1:name}InteractorType? { get set }

    func get(parameters: [String: Any]? = nil)
}

final class ${1:name}Presenter: ${1:name}PresenterType {
    weak var output: ${1:name}PresenterOutputType?

    var interactor: ${1:name}InteractorType?

    func get(parameters: [String: Any]? = nil) {
        interactor?.get(parameters: parameters)
    }
}

extension ${1:name}Presenter: ${1:name}InteractorOutputType {
    func dispatch(${2:event_name} event: RequestEvent<${3:model_type}>) {
        switch event {
        case .loading(let loading):
            output?.dispatch(${2:event_name}: .loading(loading))
        case .success(let ${4:model}):
            output?.dispatch(${2:event_name}: .success(${4:model}))
        case .failure(let error):
            output?.dispatch(${2:event_name}: .failure(error))
        }
    }
}
endsnippet

snippet recordmode "setUp test override for quickly enabling record mode" b
override func setUp() {
    super.setUp()

    recordMode = true
}
endsnippet

snippet test "A basic test case" b
@testable import ${1:TestModule}
import XCTest

final class ${2:TestClass}: ${3:XC}TestCase {
    func test${4:Default}() {
        ${5:test code}
    }
}
endsnippet
